<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Void Framework</title><link>https://voidframework.dev/</link><description>Recent content on Void Framework</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://voidframework.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Data source</title><link>https://voidframework.dev/doc/databases/datasource/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/databases/datasource/</guid><description>Your application needs to connect to one or more databases? Void Framework is capable of handling multiple data sources at the same time through the use of DataSourceManager. It will provide all the necessary methods to obtain a connection from the desired data source. Each data source can be configured independently. Your application can, for example, be connected to PostgreSQL and Oracle at the same time.
Configuration Void Framework offers different implementations, depending on the implementation chosen, the configuration keys may change.</description></item><item><title>Hibernate</title><link>https://voidframework.dev/doc/databases/persistence-hibernate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/databases/persistence-hibernate/</guid><description>Hibernate is an Object Relational Mapper (ORM). It provides a framework for mapping an object-oriented domain model to a relational database.
&amp;nbsp; Void Framework uses Hibernate 6 (or higher), which that means Java persistence is no longer defined by the Java Persistence API under Java EE, but rather by to the Jakarta Persistence 3.0 specification under Jakarta EE. This means the javax.persistence package is no longer available and is replaced by jakarta.</description></item><item><title>Getting Started</title><link>https://voidframework.dev/doc/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/getting-started/</guid><description/></item><item><title>Core</title><link>https://voidframework.dev/doc/core/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/core/</guid><description/></item><item><title>Databases</title><link>https://voidframework.dev/doc/databases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/databases/</guid><description/></item><item><title>Cache</title><link>https://voidframework.dev/doc/cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/cache/</guid><description/></item><item><title>Internationalization</title><link>https://voidframework.dev/doc/i18n/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/i18n/</guid><description/></item><item><title>Web</title><link>https://voidframework.dev/doc/web/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/web/</guid><description/></item><item><title>Boot sequence</title><link>https://voidframework.dev/doc/core/boot-sequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/core/boot-sequence/</guid><description>Below is a diagram describing the boot sequence of Void Framework.
S c a n C l N a O s s p a t h s c R l L e L L a o g i o s ( a i f a s 2 d s e d p a t C a ) G e y c t u r c o h i l n .</description></item><item><title>Cache engine : In-memory</title><link>https://voidframework.dev/doc/cache/in-memory-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/cache/in-memory-cache/</guid><description>This implementation of the cache engine is convenient during the development phase because it avoids the installation of a distributed cache server. However, this implementation is absolutely not recommended for use in a production environment.
Installation &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;dev.voidframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;voidframework-cache&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; To enable In-memory cache engine, you have to set voidframework.cache.engine to dev.voidframework.cache.engine.MemoryCacheEngine in your application configuration file.
Configuration The following configuration key can be used in the configuration file of your application.</description></item><item><title>Cache engine : Redis</title><link>https://voidframework.dev/doc/cache/redis-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/cache/redis-cache/</guid><description>This implementation requires the voidframework-redis module to be properly configured.
Installation &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;dev.voidframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;voidframework-cache-redis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; To enable In-memory cache engine, you have to set voidframework.cache.engine to dev.voidframework.cache.engine.RedisCacheEngine in your application configuration file.</description></item><item><title>Class scanning</title><link>https://voidframework.dev/doc/core/class-scanning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/core/class-scanning/</guid><description>The core of the Void Framework is based on the scanning of different paths to discover elements to load. 3 types of elements are recognised during the scan:
Bindable classes (see below) classes implementing the TypeConverter interface classes which extend AbstractModule (Guice) Bindable @Bindable is a specific annotation that allows annotated classes to be considered as candidates for auto-detection during classpath scan. Other class-level specialized annotations can also be considered as identifying a bindable and provide a clearer identification of the purpose of the class.</description></item><item><title>Controller</title><link>https://voidframework.dev/doc/web/controller/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/web/controller/</guid><description>Controllers receive incoming web requests, process them and return a result. They are the entry point to your web application. Controllers can return almost any type of data, as long as it is handled by the Result object. It is a convention imposed by Void Framework that methods which handle incoming requests must return a Result.
A simple controller @Singleton @WebController public class ExampleController { @RequestRoute public Result homepage() { return Result.</description></item><item><title>Creating a new application</title><link>https://voidframework.dev/doc/getting-started/new-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/getting-started/new-application/</guid><description>To create a new application with Void Framework, simply create a new Maven project and then add the necessary dependencies.
Maven The very first dependency to include in your pom.xml is voidframework-core, without it you will not be able to start the application. The dependencies to be added will depend on the features you wish to use on your application, so do not hesitate to consult the different chapters of the documentation.</description></item><item><title>Documentation</title><link>https://voidframework.dev/doc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/</guid><description/></item><item><title>Life cycle</title><link>https://voidframework.dev/doc/core/life-cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/core/life-cycle/</guid><description>Void Framework provides a way to manage the life of a component. The @LifeCycleStart and @LifeCycleStop annotations allow you to define the methods to be called automatically when the application is started and stopped.
&amp;nbsp; It is possible to have several methods of a class annotated with the same annotation. @LifeCycleStart Indicates that this method should be called when the application starts.
The annotation accepts the following parameter:
priority is used to define when the method will be called in relation to the others.</description></item><item><title>Release notes</title><link>https://voidframework.dev/releasenotes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/releasenotes/</guid><description>1.1.1 2022-07-24
Improved Change CSRF signature algorithm to HMACSHA256 Fixed Error 500 CSRF when POST request render template 1.1.0 2022-07-22
New Methods on Reflection util class: getAnnotatedField(Object, Class&lt;? extends Annotation>) and getAnnotatedField(Class, Class&lt;? extends Annotation>) New Configuration keys to define number of I/O and Worker threads (Web) New Redis (base + cache + healthcheck) New CSRF token Improved No longer necessary for HealthChecker to be Singleton Improved Add cache abstraction helper Improved Session signature key configuration is now required Improved Rename ApplicationLauncher to VoidApplication Improved Updated version of all dependencies Fixed Cookie revocation not working Fixed C3P0/HikariCP settings Fixed Issue on routes sorting when regex and capture regex are used Fixed Assets not found when devMode=false Fixed Hibernate : Models not found when application is compiled 1.</description></item><item><title>Requirements</title><link>https://voidframework.dev/doc/getting-started/requirements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/getting-started/requirements/</guid><description>To use the Void Framework, you need Java JDK 17 or higher, Maven 3 or higher and the Void Framework JAR files. These JAR files are published to the Maven Repository.
Verifying and installing Java To check that you have Java JDK 17 or higher, enter the following in a shell:
#&amp;gt; java -version You should see something like:
openjdk version &amp;#34;17.0.2&amp;#34; 2022-01-18 OpenJDK Runtime Environment (build 17.0.2+8-86) OpenJDK 64-Bit Server VM (build 17.</description></item><item><title>Type conversion</title><link>https://voidframework.dev/doc/core/type-conversion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/core/type-conversion/</guid><description>Type conversion is a mechanism for converting data from one type to another. For example, convert the string &amp;ldquo;1234&amp;rdquo; to an integer. The conversion is very useful when moving from one layer to another in DDD-based architectures. It is also used in the web feature to convert path param to typed values in the controller.
Using conversion The conversion is used via the Conversion service which is accessible via direct injection.</description></item><item><title>Upgrading from old version</title><link>https://voidframework.dev/doc/getting-started/upgrading-from-old-version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/getting-started/upgrading-from-old-version/</guid><description>Sometimes important changes will be introduced that will break the backwards compatibility with older versions of the framework. On this page you will find the necessary steps to make your application work with the latest version.
1.1.0 ApplicationLauncher has been renamed to VoidApplication The setting key voidframework.web.session.signatureKey is now required</description></item><item><title>Using cache</title><link>https://voidframework.dev/doc/cache/using-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/cache/using-cache/</guid><description>Void Framework provides the tools to use a cache system. Caching can be done in two different ways, via the use of annotations or programmatically via the use of the CacheEngine.
&amp;nbsp; If no CacheEngine implementation was specified, the cache will not be active. &amp;nbsp; Note that caching a Result (Web) object can lead to errors during deserialization, especially if Result contains an InputStream. Serialization and deserialization of cached objects is handled by the Kryo library.</description></item><item><title>Using internationalization</title><link>https://voidframework.dev/doc/internationalization/using-i18n/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voidframework.dev/doc/internationalization/using-i18n/</guid><description>Depending on your needs, you may need to use translated messages in different languages. By default the Void Framework provides a ResourceBundle based implementation. If your needs require more advanced management or different storage (ie: DB rather than files), you can easily use your own implementation.
To enable this module, just add following lines to the pom.xml file of your project.
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;dev.voidframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;voidframework-i18n&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Defining messages Translations should be placed in a file named messages_&amp;lt;LANG&amp;gt;.</description></item></channel></rss>